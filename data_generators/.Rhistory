?stopwords()
#LIBRARIES#
library(tm)
library(lsa)
library(cluster)
library(LSAfun)
stopwordList <- c(
stopwords(),'a','b','c','d','i','ii','iii','iv',
'secretary','state','ministry','majesty',
'government','many','ask','whether',
'assessment','further','pursuant','justice',
'minister','steps','department','question'
)
?stopwords()
?weightSMART()
library(rvest)
library(tm)
#### PARAMETERS ####
#paste the url for your search set of questions here within the quotation marks
link = "http://www.parliament.uk/business/publications/written-questions-answers-statements/written-questions-answers/?answered-from=2014-06-04&answered-to=2017-05-05&dept=54&house=commons%2clords&max=1000&page=1&questiontype=AllQuestions&use-dates=True"
#write the file name - it will save to whatever folder R is standardly writing out to
saveFile = 'MoJPQsNew.csv'
#You should be able to now just run everything below here and it will spit out the results into
#the file you've specified above.
#### FUNCTIONS ####
#function to scrape the information we want for the ith question on a given page
Qscrape <- function(i,htmlSession){
#this qTag business seems like a long way round, but it's to avoid running into trouble when
#question IDs have the same string of digits as other links on the page, at which point a
#simple 'follow_link("questionID")' approach just follows the first link containing the string
#of digits in question, with often the wrong result. Whereas this way, though fiddly, gets results.
qTag <- 2*i-1
qTag <- if(qTag<10){paste("0",as.String(qTag),sep="")}else{as.String(qTag)}
qLink<-paste("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlQnAList_rptQuestions_ctl",qTag,"_ctrlQuestionItem_hypQuestionUIN",sep="")
QSesh <- htmlSession %>% follow_link(css = qLink)
Qhtml <- read_html(QSesh)
correctedDate <- "N/A"
question <-  Qhtml %>% html_nodes(".qna-result-question-text") %>% html_text()
if(length(question)==0){question <- "N/A"}
date <- Qhtml %>% html_nodes(".qna-result-question-date span") %>% html_text()
if(length(date)==0){date <- "N/A"}
answerDate <- Qhtml %>% html_nodes(".qna-result-answer-date") %>% html_text()
if(length(answerDate)==0){answerDate <- "N/A"}
if(length(answerDate)>1){ #if the answer takes up several paragraphs we want to squeeze it all into one entry
answerDate <- Qhtml %>% html_nodes("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlAnswerItem_divAnswer .qna-result-answer-date") %>% html_text()
correctedDate <- Qhtml %>% html_nodes("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlAnswerItemMinisterialCorrection_divAnswer .qna-result-answer-date") %>% html_text()}
questionID <- Qhtml %>% html_nodes("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlQuestionItem_hypQuestionUIN") %>% html_text()
if(length(questionID)==0){questionID <- "N/A"}
answer <- Qhtml %>% html_nodes("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlAnswerItemMinisterialCorrection_divAnswer p") %>% html_text()
if(length(answer)==0){ #sometimes the answers are under a different CSS tag
answer <- Qhtml %>% html_nodes(".qna-result-answer-content") %>% html_text()}
if(length(answer)==0){ #sometimes the answers are under a different CSS tag
answer <- Qhtml %>% html_nodes("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlAnswerItem_divAnswer p") %>% html_text()}
if(length(answer)==0){
answer <- "N/A"}
if(length(answer)>1){ #if the answer takes up several paragraphs we want to squeeze it all into one entry
answer <- paste(answer,collapse = "; ")}
QMP <- Qhtml %>% html_nodes("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlQuestionItem_ctlMemberHypLink") %>% html_text()
if(length(QMP)==0){QMP <- "N/A"}
Qconst <- Qhtml %>% html_nodes("#divConstituency") %>% html_text()
if(length(Qconst)==0){Qconst <- "N/A"}
AMP <- Qhtml %>% html_nodes("#ctl00_ctl00_FormContent_SiteSpecificPlaceholder_PageContent_ctrlAnswerItem_ctlMemberHypLink") %>% html_text()
if(length(AMP)==0){AMP <- "N/A"}
return(list(question = question, date = date, answerDate = answerDate, correctedDate = correctedDate, questionID = questionID, answer = answer, QMP = QMP, Qconst = Qconst, AMP = AMP))
}
#### CODE ####
#this defines your html session
MoJPQSesh <- html_session(link)
#total number of questions in our selection
totalQs <- read_html(MoJPQSesh) %>% html_nodes(".record-count-highlight") %>% html_text()
totalQs <- as.numeric(totalQs[1])
#Now some empty holders for the eventual results
questionsVec <- rep("unused",totalQs)
datesVec <- rep("unused",totalQs)
answerDatesVec <- rep("unused",totalQs)
correctedDatesVec <- rep("unused",totalQs)
questionIDsVec <- rep("unused",totalQs)
answersVec <- rep("unused",totalQs)
QMPsVec <- rep("unused",totalQs)
QconstsVec <- rep("unused",totalQs)
AMPsVec <- rep("unused",totalQs)
#A placeholder for whether or not we've finished the scrape, and an index for what question we're on
finished <-0
j <- 1
#Now the bit that does the actual scraping:
#we loop through each page and add the scrapings to each result holder
#once we hit a page that lacks a 'Next' link we assume that we've finished
while(finished == 0){
#get the number of questions on the page by counting them
qNums <- MoJPQSesh %>% html_nodes(".qna-result-question-uin a") %>% html_text()
for(i in 1:length(qNums)){
#for each question, run the Question Scraper function
Qresults <- Qscrape(i,MoJPQSesh)
#then add the results to the appropriate slot in our results vectors
questionsVec[j] <- Qresults$question
datesVec[j] <- Qresults$date
answerDatesVec[j] <- Qresults$answerDate
correctedDatesVec[j] <- Qresults$correctedDate
questionIDsVec[j] <- Qresults$questionID
answersVec[j] <- Qresults$answer
QMPsVec[j] <- Qresults$QMP
QconstsVec[j] <- Qresults$Qconst
AMPsVec[j] <- Qresults$AMP
#now click the index on to the next question and loop round again
j <- j+1
}
#define the link we're going to next
nextLink <- read_html(MoJPQSesh) %>% html_nodes("a:nth-child(7)") %>% html_attr("href")
#if the link exists, follow it and go round the loop again, otherwise we're done
if(length(nextLink)!=0){
MoJPQSesh <- MoJPQSesh %>% follow_link("Next")
} else {finished = 1}
}
